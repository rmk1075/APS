/**
 * overview
 * 
 * 수열의 부분 수열에 대해서 탐색을 수행한다.
 * 스타 수열에서는 각 요소가 2개씩 짝을 지어서 조건을 확인한다.
 * 각 요소를 2개씩 묶어서 스타 수열에 들어갈 수 있는 요소의 위치의 개수를 모두 구한 뒤 2를 곱하여 스타 수열의 길이를 반환한다.
 * 
 * 전체 수열에서 만들 수 있는 모든 부분 수열을 탐색하게 되면 복잡도가 너무 커지기 때문에 이전 탐색 정보를 저장하여 dp로 문제를 해결한다.
 * 
 * description
 * 
 * dp 변수는 이전 까지의 탐색에서 해당 값이 마지막으로 위치했던 index 와 현재까지 나온 count 를 구한다.
 * i 번째 위치에서 i, i + 1 을 짝을 지어서 해당 집합이 부분 수열에 들어갔을 때의 값을 구한다.
 * 우선 i, i + 1 번째 값이 같은지 확인을 하고 같은 경우는 해당 집합을 포함하지 않고 넘어간다.
 * 둘의 값이 다른 경우 dp 배열을 확인한다.
 * 만약 a[i] 값이 마지막으로 포함된 위치와 i 의 차이가 1보다 작은 경우에는 3번째 조건을 위반하기 때문에 값을 포함하지 않고 넘어간다.
 * 만약 두 위치의 차이가 1보다 큰 경우에는 마지막으로 포함된 위치를 i 로 변경하고 count 를 1 더해준다.
 * 이때 주의해야할 점은 {a[i], a[i + 1]} 의 집합으로 조건을 판단하기 때문에 둘다 위치를 저장할 때 i 로 저장한다.
 * 마지막에 dp 배열을 탐색해서 가장 많은 집합을 저장하는 숫자의 값을 찾아서 두배로 곱해서 반환한다.
 */
class Solution {
    public int solution(int[] a) {
        int N = a.length;
        if(N == 1) return 0;
        int[][] dp = new int[N][2]; // {last index, count}
        for(int i = 0; i < N; i++) dp[i][0] = -2;
        for(int i = 0; i < N - 1; i++) {
            int x = a[i];
            int y = a[i + 1];
            if(x == y) continue;
            if(1 < i - dp[x][0]) {
                dp[x][0] = i;
                dp[x][1]++;
            }
            if(1 < i - dp[y][0]) {
                dp[y][0] = i;
                dp[y][1]++;
            }
        }
        int answer = 0;
        for(int[] arr : dp) {
            answer = Math.max(answer, arr[1]);
        }
        return answer * 2;
    }
}